<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>why_postulate_external_objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style setby="vwformat">
</style>
</head>
<body>

<p>
<span id="-draft0.0"></span><span class="tag" id="draft0.0">draft0.0</span>
</p>
<div id="why postulate external objects"><h1 id="why postulate external objects" class="header"><a href="#why postulate external objects">why postulate external objects</a></h1></div>
<div id="why postulate external objects-short"><h6 id="short" class="header"><a href="#why postulate external objects-short">short</a></h6></div>

<div id="short exemplar"><h1 id="short exemplar" class="header"><a href="#short exemplar">short exemplar</a></h1></div>
<p>
The reason for postulating external objects, and hence, in a sense the
justification for believing that external objects exist
</p>

<div id="main"><h1 id="main" class="header"><a href="#main">main</a></h1></div>
<p>
let me try this run-up: Rhetorical question 1) Why do we need to posit external
objects at all - (physical) chairs, tables, electrons, notebooks and messenger
bags?
</p>

<p>
Answer: because of the complexity (in quite a well defined computational sense)
of our observations. It is not that we could not "explain" our observations
without such posits, but that we could not even describe the patterns of
observations that we are expect (i.e. that are compatible with our current
theory of the world) without postulating objects.
</p>

<p>
This is connected with Quine's "to be is to be the value of a variable" and his
mild obsession with quantification.  Propositional calculus (i.e. truth
functional logic) is at the lower order of complexity that logicians describe as
having a "decision procedure". Computer scientists describe such collections as
being "recursively decidable". Quantificational calculus (in which <em>objects</em> are
posited) is at the level logicians describe as having a "proof procedure". [and
computer scientists describe such collections as being "recursively
enumerable".]
</p>

<p>
Frege's breakthrough of quantification raised formal logical systems to the
level of complexity required for mathematics (the level of proof procedures).
WHat is it to postulate an object? To include it among the values of variables
that your quantifiers range over (or for asuch inclusion to be required inorder
to make the sentnces of you theory true.)
</p>

<p>
To put it in terms of my fallback computer analogy - a computer programmer
<span id="main-cannot"></span><strong id="cannot">cannot</strong> describe the patterns of input-output that their program is disposed to
produce <span id="main-without describing the inner machinations of their program"></span><strong id="without describing the inner machinations of their program">without describing the inner machinations of their program</strong> (i.e. the
objects inside the program/machine).
</p>

<p>
This may very likely appear irrelvant to you - that is fine - but do you have
some sense of why I am claiming that the postulation of external objects is
required by the complexity of our expectations of future observation? Agreement
is not required, but I need to establish some minimal level of clarity of this
claim before I can move on.
</p>

<p>
=====
We are heading towards beliefs + objects of belief.
</p>

<p>
Lets return to my favorite computer style mind-pump/exemplar.
</p>

<p>
Suppose you are sitting at a computer screen+keyboard. The computer screen is,
in this case an epistemic bottleneck
(<a href="https://surprisedagain.github.io/philosophy/evidence.html),">https://surprisedagain.github.io/philosophy/evidence.html),</a> between you and the
computer innards. You only know of the latter through the former.
</p>

<p>
You form the well justified belief (not using that to posit beliefs just yet,
just using ordinary language and not committed to any particular analysis of
that language at this early stage - keeping our options open) that the computer
will distinguish between the goedel numbers of turing machines that halt and
turing machines that dont.
</p>

<p>
SO you believe that if you type in a number the computer screen will first
display that number for a little while and then display the text "yes" if that
number is the goedel number of a turing machine that halts, and "no" otherwise.
</p>

<p>
Where on earth did the turing machines and the gpedel numbers come from? This is
a classic problem called the "halting problem" {:todo: create link here} (I am 97% sure @TheMilkman37
knows this already, hopefully doesnt hurt to remind). It is the first and prime
exemplar of a problem at the "recursively enumerable" (but not decidable) level
of complexity.
</p>

<p>
Next Installment: This gives you reason to believe there must be some internal processing going on in the computer - i.e. something beyond what you see on the screen 
</p>

<p>
[9:38 AM]TheMilkman37: Following so far
</p>

<p>
[9:38 AM]surprised: great
[9:41 AM]surprised: So 2 points to note:
</p>


<ol>
<li>
if the computer program were simpler than this - if it were just telling
   whether a number you input was even or odd, for instance, that problem would
   be solved/implemented by a "computer" which contained only wires. It would
   not need to store anything. The relation between the input and output could
   be expressed by a truth function (over pixels of the screen at times). I.e
   .if pixel 5 and pixel 7 are on at time T1 then pixel 6 is on at time T2.

</ol>

<p>
[9:42 AM]surprised: But to solve the halting problem there need to be some
internal computation going on. In effect to solve this problem there is no way
to avoid having to actually run each turing machine one step at a time, and
hence you will need to keep track of (i.e. store) the state of that turing
machine WITHOUT displaying those states on the computer screen you are looking
at.
</p>

<p>
[9:43 AM]surprised: There must be some internal computation, that internal
computation must involve storing states, therefore you are justified in
believing that a machine that can recognise goedel numers of turing machings
that halt must have some things going on inside it.
</p>

<p>
[9:48 AM]surprised: 2) We are in the usual inductive situation. You might be
wrong about the computer you are looking at - it might only be a lookup table
that stores the goedel numebr of the first 2000 halting turing machines, and it
might be just looking them up and as soon as you type in a number that is too
large then it fails. In normal computer terms - instead of running a program -
it might run out of memory. You do not have any "guaranteed" demonstration that
the computer is computing the halting function, and hence no guaranteed
demonstration that it has innards storing states. The hypothesis is one which
(is normally taken to be) justified by induction. To the extent that the
hypothesis about the disposition of the machine to produce output in response to
input is justifed (by any means, inductive if you so wish), so to is justified
the belief that the machine has innards.
</p>


<div id="other related cards"><h1 id="other related cards" class="header"><a href="#other related cards">other related cards</a></h1></div>

</body>
</html>
